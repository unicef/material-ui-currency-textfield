'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var resolve = require('resolve');

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function startsWith(string, prefix) {
  return string.lastIndexOf(prefix, 0) === 0;
}

var DEFAULT_OPTIONS = {
  path: '.babelrc',
  findRollupPresets: false,
  addModuleOptions: true,
  addExternalHelpersPlugin: true,
  resolve: resolve.sync
};

function babelrc() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (typeof options === 'string') {
    options = { path: options };
  }

  var resolvedOptions = _extends({}, DEFAULT_OPTIONS, options);

  if (!resolvedOptions.config && typeof resolvedOptions.path === 'string') {
    resolvedOptions.config = JSON.parse(fs.readFileSync(resolvedOptions.path, { encoding: 'utf8' }));
  }

  return configWithoutModules(resolvedOptions.config, resolvedOptions);
}

function configWithoutModules(config, options) {
  var result = {};

  for (var _key in config) {
    if (Object.prototype.hasOwnProperty.call(config, _key)) {
      if (_key === 'presets' && config.presets) {
        // Replace the es2015 preset with the es2015-rollup preset.
        result.presets = config.presets.map(function (preset) {
          return mapPreset(preset, options);
        });
      } else if (_key === 'plugins' && config.plugins) {
        // Remove any explicit module plugins, e.g. es2015-modules-commonjs.
        result.plugins = config.plugins.filter(function (plugin) {
          return !startsWith(plugin, 'es2015-modules-');
        });
      } else {
        result[_key] = config[_key];
      }
    }
  }

  if (options.addExternalHelpersPlugin) {
    if (!result.plugins) {
      result.plugins = ['external-helpers'];
    } else {
      result.plugins = [].concat(toConsumableArray(result.plugins), ['external-helpers']);
    }
  }

  // Make sure babel does not look for the babelrc file.
  result.babelrc = false;

  return result;
}

function mapPreset(preset, options) {
  var info = getPresetInfo(preset);

  if (!info) {
    return preset;
  }

  if (options.findRollupPresets && hasRollupVersionOfPreset(info.name, options.resolve || resolve.sync)) {
    return [info.name + '-rollup', info.options];
  } else if (options.addModuleOptions) {
    return [info.name, _extends({}, info.options, { modules: false })];
  } else {
    return preset;
  }
}

function getPresetInfo(preset) {
  if (typeof preset === 'string') {
    return { name: preset, options: {} };
  } else if (Array.isArray(preset)) {
    var _name = preset[0];
    var _options = preset[1] || {};

    if (typeof _name === 'string' && (typeof _options === 'undefined' ? 'undefined' : _typeof(_options)) === 'object') {
      return { name: _name, options: _options };
    }
  }

  return null;
}

function hasRollupVersionOfPreset(preset, resolve) {
  try {
    // this will throw if it can't resolve it
    resolve('babel-preset-' + preset + '-rollup');
    return true;
  } catch (err) {
    return false;
  }
}

exports['default'] = babelrc;
exports.configWithoutModules = configWithoutModules;